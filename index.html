<!--
  Mobile HCI (H): Coursework Exercise 2024-2025
  Dulapah Vibulsanti - 2920990v
  "Tilt-flick grid-based input"
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MHCI - Dulapah Vibulsanti 2920990v</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
      }
      .control-button {
        font-size: 14px;
        cursor: pointer;
        margin: 5px;
        padding: 8px 16px;
      }
      .stats-container {
        margin: 20px 0;
      }
      .value {
        font-weight: bold;
        color: #2196f3;
      }
      .device-container {
        width: 260px;
        height: 480px;
        border: 2px solid #333;
        border-radius: 20px;
        margin: 20px auto;
        padding: 20px;
        background: #f5f5f5;
        position: relative;
      }
      .button-container {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(5, 1fr);
        gap: 10px;
        height: 100%;
      }
      .grid-button {
        padding: 10px;
        font-size: 16px;
        border: 2px solid #ccc;
        background: white;
        cursor: pointer;
      }
      .grid-button.selected {
        border-color: #2196f3;
        background: #e3f2fd;
      }
      .grid-overlay {
        position: absolute;
        inset: 20px;
        pointer-events: none;
        display: none;
        animation: fade-in 1s cubic-bezier(0.19, 1, 0.22, 1) both;
      }
      .grid-container {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(8, 1fr);
        height: 100%;
        background: transparent;
      }
      .coord-label {
        padding: 2px 5px;
        border: 1px solid #999;
        border-radius: 3px;
        background: white;
        outline: 1px double #999;
        outline-offset: 1px;
      }
      .grid-cell {
        display: flex;
        justify-content: center;
        align-items: center;
        border: 0.75px solid black;
        font-size: 14px;
        padding: 5px;
      }
      .grid-cell.selected {
        background: rgba(33, 150, 243, 0.2);
        border: 2px solid #2196f3;
      }
      .grid-cell.dimmed {
        background: rgba(0, 0, 0, 0.5);
        border-color: transparent;
      }
      .grid-cell.dimmed .coord-label {
        display: none;
      }
      .magnifier-window {
        position: absolute;
        width: 160px;
        height: 160px;
        background: white;
        border: 2px solid black;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        display: none;
        z-index: 1000;
        left: 50%;
        transform: translateX(-50%);
        overflow: hidden;
      }
      @keyframes fade-in {
        0% {
          opacity: 0;
        }
        100% {
          opacity: 1;
        }
      }
      /* Tutorial section styling */
      .tutorial-section {
        margin: 20px 0;
      }
      details summary {
        cursor: pointer;
        font-weight: bold;
        margin-bottom: 10px;
        color: #2196f3;
      }
      .step-container {
        margin-bottom: 25px;
        border-left: 3px solid #2196f3;
        padding-left: 15px;
      }
      .step-container h4 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #2196f3;
      }
      .gesture-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 15px;
      }
      .gesture-card {
        margin-bottom: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .gesture-title {
        font-weight: bold;
        margin-bottom: 8px;
        text-align: center;
      }
      .gesture-description {
        font-size: 14px;
        margin-bottom: 10px;
        text-align: center;
      }
      .phone-animation-container {
        width: 120px;
        height: 200px;
        position: relative;
        margin: 10px auto;
      }
      .phone-outline {
        width: 80px;
        height: 160px;
        border: 2px solid #333;
        border-radius: 12px;
        position: absolute;
        top: 20px;
        left: 20px;
        background: #eee;
        overflow: hidden;
      }
      .phone-screen {
        width: 70px;
        height: 150px;
        background: rgba(33, 150, 243, 0.2);
        position: absolute;
        top: 5px;
        left: 5px;
        border-radius: 5px;
      }
      .tilt-left .phone-outline {
        animation: flipLeft 0.8s ease-in-out infinite;
      }
      @keyframes flipLeft {
        0%,
        20%,
        100% {
          transform: perspective(500px) rotateY(0deg);
        }
        40%,
        60% {
          transform: perspective(500px) rotateY(-30deg);
        }
        80% {
          transform: perspective(500px) rotateY(0deg);
        }
      }
      .tilt-right .phone-outline {
        animation: flipRight 0.8s ease-in-out infinite;
      }
      @keyframes flipRight {
        0%,
        20%,
        100% {
          transform: perspective(500px) rotateY(0deg);
        }
        40%,
        60% {
          transform: perspective(500px) rotateY(30deg);
        }
        80% {
          transform: perspective(500px) rotateY(0deg);
        }
      }
      .tilt-forward .phone-outline {
        animation: tiltForward 0.8s ease-in-out infinite;
      }
      @keyframes tiltForward {
        0%,
        20%,
        100% {
          transform: perspective(500px) rotateX(0deg);
        }
        40%,
        60% {
          transform: perspective(500px) rotateX(25deg);
        }
        80% {
          transform: perspective(500px) rotateX(0deg);
        }
      }
      .tilt-backward .phone-outline {
        animation: tiltBackward 0.8s ease-in-out infinite;
      }
      @keyframes tiltBackward {
        0%,
        20%,
        100% {
          transform: perspective(500px) rotateX(0deg);
        }
        40%,
        60% {
          transform: perspective(500px) rotateX(-25deg);
        }
        80% {
          transform: perspective(500px) rotateX(0deg);
        }
      }
      .shake-once .phone-outline {
        animation: shakeOnce 0.8s ease-in-out infinite;
      }
      @keyframes shakeOnce {
        0%,
        20%,
        100% {
          transform: translateX(0);
        }
        40% {
          transform: translateX(-10px);
        }
        60% {
          transform: translateX(10px);
        }
        80% {
          transform: translateX(0);
        }
      }
      .shake-twice .phone-outline {
        animation: shakeTwice 1.2s ease-in-out infinite;
      }
      @keyframes shakeTwice {
        0%,
        10%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-10px);
        }
        35% {
          transform: translateX(10px);
        }
        45% {
          transform: translateX(0);
        }
        60% {
          transform: translateX(-10px);
        }
        70% {
          transform: translateX(10px);
        }
        80% {
          transform: translateX(0);
        }
      }
      .shake-thrice .phone-outline {
        animation: shakeThrice 1.5s ease-in-out infinite;
      }
      @keyframes shakeThrice {
        0%,
        5%,
        95%,
        100% {
          transform: translateX(0);
        }
        15% {
          transform: translateX(-10px);
        }
        25% {
          transform: translateX(10px);
        }
        35% {
          transform: translateX(0);
        }
        45% {
          transform: translateX(-10px);
        }
        55% {
          transform: translateX(10px);
        }
        65% {
          transform: translateX(0);
        }
        75% {
          transform: translateX(-10px);
        }
        85% {
          transform: translateX(10px);
        }
      }
      .direction-arrow {
        position: absolute;
        width: 30px;
        height: 30px;
        background-color: #2196f3;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: bold;
        font-size: 18px;
        opacity: 0;
      }
      .tilt-left .arrow-left {
        left: -25px;
        top: 50%;
        transform: translateY(-50%);
        animation: fadeArrow 0.8s ease-in-out infinite;
      }
      .tilt-right .arrow-right {
        right: -25px;
        top: 50%;
        transform: translateY(-50%);
        animation: fadeArrow 0.8s ease-in-out infinite;
      }
      .tilt-forward .arrow-up {
        top: -15px;
        left: 50%;
        transform: translateX(-45%);
        animation: fadeArrow 0.8s ease-in-out infinite;
      }
      .tilt-backward .arrow-down {
        bottom: -15px;
        left: 50%;
        transform: translateX(-45%);
        animation: fadeArrow 0.8s ease-in-out infinite;
      }
      @keyframes fadeArrow {
        0%,
        20%,
        100% {
          opacity: 0;
        }
        40%,
        60% {
          opacity: 1;
        }
        80% {
          opacity: 0;
        }
      }
    </style>
    <script>
      // Constants
      const NUM_BUTTONS = 10;
      const GRID_COLS = 4;
      const GRID_ROWS = 8;

      // Tilt and shake detection thresholds
      const TILT_FLICK_DEBOUNCE = 500;
      const TILT_BETA_THRESHOLD = 7;
      const TILT_GAMMA_THRESHOLD = 10;
      const SHAKE_THRESHOLD_DEFAULT = 8;
      const SHAKE_THRESHOLD_MAGNIFIED = 15;
      const SHAKE_WINDOW = 300;
      const MULTI_SHAKE_WINDOW = 1000;
      const SHAKE_RESET_DELAY = 1000;
      const TILT_SHAKE_IGNORE_DELAY = 1300;

      // State variables
      let currentPosition = { x: 0, y: 0 };
      let magnifiedPosition = { x: 0, y: 0 };
      let sensorsActive = false;
      let lastShake = 0;
      let shakeTimeoutId = null;
      let magnifierShakeTimeoutId = null;
      let isProcessingShake = false;
      let multiShakeCount = 0;
      let shakeStart = 0;
      let gridVisible = false;
      let lastBeta = 0;
      let lastGamma = 0;
      let lastTiltFlick = 0;
      let tiltFlickDirection = "none";
      let lastActivatedButton = null;

      /**
       * Updates the highlighted cell in the main grid based on currentPosition
       */
      function updateGridHighlight() {
        document.querySelectorAll(".grid-cell").forEach((cell) => {
          cell.classList.remove("selected");
        });

        const index = currentPosition.y * GRID_COLS + currentPosition.x;
        const cells = document.querySelectorAll(".grid-cell");
        if (cells[index]) {
          cells[index].classList.add("selected");
          // Update current cell status
          document.getElementById(
            "currentCell"
          ).textContent = `${currentPosition.x},${currentPosition.y}`;
        }
      }

      /**
       * Updates the highlighted cell in the magnified view based on magnifiedPosition
       */
      function updateMagnifiedHighlight() {
        const magnifier = document.querySelector(".magnifier-window");
        if (!magnifier) return;

        // Get the grid overlay inside the magnifier
        const gridOverlay = magnifier.querySelector(
          "div[style*='grid-template-columns']"
        );
        if (!gridOverlay) return;

        // Get all cells in the magnified view
        const cells = gridOverlay.children;

        // Reset all highlights
        for (let i = 0; i < cells.length; i++) {
          cells[i].style.backgroundColor = "";
          cells[i].style.border = "0.75px solid black";
        }

        // Convert from 0-based magnifiedPosition to index
        const index = magnifiedPosition.y * 3 + magnifiedPosition.x;

        // Apply highlight if the index is valid
        if (index >= 0 && index < cells.length) {
          cells[index].style.backgroundColor = "rgba(33, 150, 243, 0.2)";
          cells[index].style.border = "2px solid #2196f3";

          // Update the current cell display
          document.getElementById(
            "currentCell"
          ).textContent = `${currentPosition.x},${currentPosition.y} → ${magnifiedPosition.x},${magnifiedPosition.y}`;
        }
      }

      /**
       * Moves the highlight in the specified direction in either main grid or magnified view
       * @param {string} direction - Direction to move: 'right', 'left', 'forward', 'backward'
       */
      function moveHighlight(direction) {
        const magnifier = document.querySelector(".magnifier-window");
        const isMagnifiedMode = magnifier !== null;

        // Handle movement differently based on whether we're in magnified mode or not
        if (!isMagnifiedMode) {
          // Main grid movement
          switch (direction) {
            case "right":
              currentPosition.x =
                currentPosition.x >= GRID_COLS - 1 ? 0 : currentPosition.x + 1;
              break;
            case "left":
              currentPosition.x =
                currentPosition.x <= 0 ? GRID_COLS - 1 : currentPosition.x - 1;
              break;
            case "forward":
              currentPosition.y =
                currentPosition.y >= GRID_ROWS - 1 ? 0 : currentPosition.y + 1;
              break;
            case "backward":
              currentPosition.y =
                currentPosition.y <= 0 ? GRID_ROWS - 1 : currentPosition.y - 1;
              break;
          }
          updateGridHighlight();
        } else {
          // Magnified view movement (3x3 grid)
          switch (direction) {
            case "right":
              magnifiedPosition.x =
                magnifiedPosition.x >= 2 ? 0 : magnifiedPosition.x + 1;
              break;
            case "left":
              magnifiedPosition.x =
                magnifiedPosition.x <= 0 ? 2 : magnifiedPosition.x - 1;
              break;
            case "forward":
              magnifiedPosition.y =
                magnifiedPosition.y >= 2 ? 0 : magnifiedPosition.y + 1;
              break;
            case "backward":
              magnifiedPosition.y =
                magnifiedPosition.y <= 0 ? 2 : magnifiedPosition.y - 1;
              break;
          }
          updateMagnifiedHighlight();
        }
      }

      /**
       * Generates the button grid and coordinate grid
       */
      function generateGrids() {
        // Generate main buttons
        const buttonContainer = document.querySelector(".button-container");
        for (let i = 1; i <= NUM_BUTTONS; i++) {
          const button = document.createElement("button");
          button.className = "grid-button";
          button.textContent = `Button ${i}`;
          buttonContainer.appendChild(button);
        }

        // Generate grid cells
        const gridContainer = document.querySelector(".grid-container");
        for (let row = 0; row < GRID_ROWS; row++) {
          for (let col = 0; col < GRID_COLS; col++) {
            const cell = document.createElement("div");
            cell.className = "grid-cell";
            const coordLabel = document.createElement("span");
            coordLabel.className = "coord-label";
            coordLabel.textContent = `${col},${row}`;
            cell.appendChild(coordLabel);
            gridContainer.appendChild(cell);
          }
        }
      }

      /**
       * Utility function to round numbers to 2 decimal places
       * @param {number} x - Number to round
       * @returns {number} Rounded number
       */
      function roundNumber(x) {
        return Math.round((x + Number.EPSILON) * 100) / 100;
      }

      /**
       * Maps grid coordinates to a button in the UI
       * @param {number} x - X coordinate in the grid
       * @param {number} y - Y coordinate in the grid
       * @returns {HTMLElement|null} Button element or null if no button found
       */
      function calculateButtonFromCell(x, y) {
        // Get button container dimensions
        const container = document.querySelector(".button-container");
        const rect = container.getBoundingClientRect();

        // Calculate relative position within container
        const cellWidth = rect.width / GRID_COLS;
        const cellHeight = rect.height / GRID_ROWS;

        // Get center point of current cell
        const centerX = (x + 0.5) * cellWidth;
        const centerY = (y + 0.5) * cellHeight;

        // Find button at this position
        const buttons = document.querySelectorAll(".grid-button");
        for (let button of buttons) {
          const buttonRect = button.getBoundingClientRect();
          const buttonRelativeRect = {
            left: buttonRect.left - rect.left,
            right: buttonRect.right - rect.left,
            top: buttonRect.top - rect.top,
            bottom: buttonRect.bottom - rect.top,
          };

          if (
            centerX >= buttonRelativeRect.left &&
            centerX <= buttonRelativeRect.right &&
            centerY >= buttonRelativeRect.top &&
            centerY <= buttonRelativeRect.bottom
          ) {
            return button;
          }
        }
        return null;
      }

      /**
       * Activates (highlights) a button and updates the UI
       * @param {HTMLElement} button - Button to activate
       */
      function activateButton(button) {
        if (button) {
          // Remove previous highlight
          if (lastActivatedButton) {
            lastActivatedButton.classList.remove("selected");
          }

          // Highlight new button and update stats
          button.classList.add("selected");
          lastActivatedButton = button;
          document.getElementById("activatedButton").textContent =
            button.textContent;

          // Add visual feedback
          button.style.transform = "scale(0.95)";
          setTimeout(() => {
            button.style.transform = "scale(1)";
          }, 100);
        }
      }

      /**
       * Resets all grid cells to their original state
       */
      function resetGridCells() {
        document.querySelectorAll(".grid-cell").forEach((cell) => {
          cell.classList.remove("dimmed", "selected");
          // Clear cell content
          cell.innerHTML = "";
          // Recreate coordinate label
          const coordLabel = document.createElement("span");
          coordLabel.className = "coord-label";
          const index = Array.from(cell.parentNode.children).indexOf(cell);
          const col = index % GRID_COLS;
          const row = Math.floor(index / GRID_COLS);
          coordLabel.textContent = `${col},${row}`;
          cell.appendChild(coordLabel);
        });
      }

      /**
       * Handles device orientation changes for tilt-flick navigation
       * @param {DeviceOrientationEvent} event - Device orientation event
       */
      function handleOrientation(event) {
        const beta = roundNumber(event.beta);
        const gamma = roundNumber(event.gamma);

        document.getElementById("currentBeta").textContent = beta;
        document.getElementById("currentGamma").textContent = gamma;

        const now = Date.now();
        const betaDiff = beta - lastBeta;
        const gammaDiff = gamma - lastGamma;

        // Detect tilt-flick gestures with debouncing
        if (now - lastTiltFlick > TILT_FLICK_DEBOUNCE) {
          if (Math.abs(betaDiff) > TILT_BETA_THRESHOLD) {
            tiltFlickDirection = betaDiff > 0 ? "forward" : "backward";
            document.getElementById("tiltFlickDirection").textContent =
              tiltFlickDirection;
            moveHighlight(tiltFlickDirection);
            lastTiltFlick = now;
          } else if (Math.abs(gammaDiff) > TILT_GAMMA_THRESHOLD) {
            tiltFlickDirection = gammaDiff > 0 ? "right" : "left";
            document.getElementById("tiltFlickDirection").textContent =
              tiltFlickDirection;
            moveHighlight(tiltFlickDirection);
            lastTiltFlick = now;
          }
        }

        lastBeta = beta;
        lastGamma = gamma;
      }

      /**
       * Creates and displays a magnified view of the selected grid cell
       * @param {number} x - X coordinate in the main grid
       * @param {number} y - Y coordinate in the main grid
       */
      async function captureAndMagnifyGrid(x, y) {
        // Remove existing magnifier if present
        const existingMagnifier = document.querySelector(".magnifier-window");
        if (existingMagnifier) {
          existingMagnifier.remove();
        }

        // Create magnifier window
        const magnifier = document.createElement("div");
        magnifier.className = "magnifier-window";
        magnifier.setAttribute("data-shake-handled", "false");

        // Position magnifier based on selected cell position
        const gridRows = GRID_ROWS;
        const midPoint = gridRows / 2;
        if (y < midPoint) {
          magnifier.style.bottom = "50px";
        } else {
          magnifier.style.top = "50px";
        }

        // Calculate the area to magnify
        const deviceContainer = document.querySelector(".device-container");
        const gridContainer = document.querySelector(".grid-container");
        const cellWidth = gridContainer.clientWidth / GRID_COLS;
        const cellHeight = gridContainer.clientHeight / GRID_ROWS;

        // Create content container for magnified view
        const content = document.createElement("div");
        content.style.width = "100%";
        content.style.height = "100%";
        content.style.position = "relative";
        content.style.overflow = "hidden";

        // Clone the device container and scale it
        const containerClone = deviceContainer.cloneNode(true);

        // Find and clear the content of the selected cell in the clone
        const selectedCell = containerClone.querySelector(
          `.grid-cell:nth-child(${y * GRID_COLS + x + 1})`
        );
        if (selectedCell) {
          selectedCell.innerHTML = ""; // This will remove the "+" grid
        }

        // Calculate scale and position adjustments
        const scale = 2.67;
        const offsetX = -x * cellWidth * scale;
        const offsetY = -y * cellHeight * scale;
        containerClone.style.transform = `scale(${scale})`;
        containerClone.style.transformOrigin = "12.6% 9.1%";
        containerClone.style.position = "absolute";
        containerClone.style.left = `${offsetX + magnifier.clientWidth / 2}px`;
        containerClone.style.top = `${offsetY + magnifier.clientHeight / 2}px`;
        content.appendChild(containerClone);

        // Create 3x3 grid overlay for the magnified view
        const gridOverlay = document.createElement("div");
        gridOverlay.style.position = "absolute";
        gridOverlay.style.top = "0";
        gridOverlay.style.left = "0";
        gridOverlay.style.right = "0";
        gridOverlay.style.bottom = "0";
        gridOverlay.style.display = "grid";
        gridOverlay.style.gridTemplateColumns = "repeat(3, 1fr)";
        gridOverlay.style.gridTemplateRows = "repeat(3, 1fr)";
        gridOverlay.style.pointerEvents = "none";
        gridOverlay.style.border = "1px solid black";

        // Add cells with coordinates to the 3x3 grid
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            const cell = document.createElement("div");
            cell.style.display = "flex";
            cell.style.justifyContent = "center";
            cell.style.alignItems = "center";
            cell.style.border = "0.75px solid black";

            // Add selection highlight for position 0,0
            if (i === 0 && j === 0) {
              cell.style.backgroundColor = "rgba(33, 150, 243, 0.2)";
              cell.style.border = "2px solid #2196f3";
            }

            const coordLabel = document.createElement("span");
            coordLabel.className = "coord-label";
            coordLabel.style.backgroundColor = "white";
            coordLabel.style.padding = "2px 4px";
            coordLabel.style.borderRadius = "3px";
            coordLabel.style.fontSize = "12px";
            coordLabel.textContent = `${j},${i}`;
            cell.appendChild(coordLabel);
            gridOverlay.appendChild(cell);
          }
        }
        content.appendChild(gridOverlay);
        magnifier.appendChild(content);
        deviceContainer.appendChild(magnifier);
        magnifier.style.display = "block";
      }

      /**
       * Prepares a grid cell for magnification by adding a 3x3 subgrid
       * @param {number} x - X coordinate in the main grid
       * @param {number} y - Y coordinate in the main grid
       */
      function prepareGridCellForMagnification(x, y) {
        document.querySelectorAll(".grid-cell").forEach((cell) => {
          const coords = cell
            .querySelector(".coord-label")
            .textContent.split(",");
          const cellX = parseInt(coords[0]);
          const cellY = parseInt(coords[1]);

          if (cellX === x && cellY === y) {
            // Clear existing content
            cell.innerHTML = "";

            // Create 3x3 subgrid for the selected cell
            const subgridContainer = document.createElement("div");
            subgridContainer.style.display = "grid";
            subgridContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
            subgridContainer.style.gridTemplateRows = "repeat(3, 1fr)";
            subgridContainer.style.height = "100%";
            subgridContainer.style.width = "100%";

            // Add the 9 subgrid points
            for (let i = 0; i < 3; i++) {
              for (let j = 0; j < 3; j++) {
                const subCell = document.createElement("div");
                subCell.style.display = "flex";
                subCell.style.justifyContent = "center";
                subCell.style.alignItems = "center";
                subCell.style.fontSize = "16px";
                subCell.style.lineHeight = 0.8;
                subCell.style.marginTop = "-2px";
                subCell.textContent = "+";
                subgridContainer.appendChild(subCell);
              }
            }

            cell.appendChild(subgridContainer);
            cell.classList.remove("dimmed");
          } else {
            cell.classList.add("dimmed");
          }
        });
      }

      /**
       * Calculates a precise position within a grid cell based on the magnified position
       * @param {number} baseX - Base X coordinate in the main grid
       * @param {number} baseY - Base Y coordinate in the main grid
       * @param {number} magX - X coordinate in the magnified view (0-2)
       * @param {number} magY - Y coordinate in the magnified view (0-2)
       * @returns {Object} Object with precise x and y coordinates
       */
      function calculatePrecisePosition(baseX, baseY, magX, magY) {
        // Convert magnified position (0-2) to fraction (0.0-1.0)
        const fractionX = magX / 2;
        const fractionY = magY / 2;

        // Calculate precise position
        // Add fractional offset to base position (e.g., 0.0, 0.5, or 1.0)
        return {
          x: baseX + fractionX,
          y: baseY + fractionY,
        };
      }

      /**
       * Maps precise coordinates to a button in the UI
       * @param {number} preciseX - Precise X coordinate in the grid
       * @param {number} preciseY - Precise Y coordinate in the grid
       * @returns {HTMLElement|null} Button element or null if no button found
       */
      function calculateButtonFromPrecisePosition(preciseX, preciseY) {
        // Get button container dimensions
        const container = document.querySelector(".button-container");
        const rect = container.getBoundingClientRect();

        // Calculate relative position within container
        const cellWidth = rect.width / GRID_COLS;
        const cellHeight = rect.height / GRID_ROWS;

        // Get precise point based on the fractional position
        const pointX = (preciseX + 0.5 / 3) * cellWidth; // Adding small offset for center of subgrid cell
        const pointY = (preciseY + 0.5 / 3) * cellHeight;

        // Find button at this position
        const buttons = document.querySelectorAll(".grid-button");
        for (let button of buttons) {
          const buttonRect = button.getBoundingClientRect();
          const buttonRelativeRect = {
            left: buttonRect.left - rect.left,
            right: buttonRect.right - rect.left,
            top: buttonRect.top - rect.top,
            bottom: buttonRect.bottom - rect.top,
          };

          if (
            pointX >= buttonRelativeRect.left &&
            pointX <= buttonRelativeRect.right &&
            pointY >= buttonRelativeRect.top &&
            pointY <= buttonRelativeRect.bottom
          ) {
            return button;
          }
        }
        return null;
      }

      /**
       * Handles shake detection in magnifier mode
       */
      function handleMagnifierShake() {
        const magnifier = document.querySelector(".magnifier-window");
        if (
          !magnifier ||
          magnifier.getAttribute("data-shake-handled") === "true"
        ) {
          return;
        }

        // Mark as handled to prevent duplicate processing
        magnifier.setAttribute("data-shake-handled", "true");

        // Calculate precise position based on magnified selection
        const precisePosition = calculatePrecisePosition(
          currentPosition.x,
          currentPosition.y,
          magnifiedPosition.x,
          magnifiedPosition.y
        );

        // Use precise position to find the button
        const button = calculateButtonFromPrecisePosition(
          precisePosition.x,
          precisePosition.y
        );

        if (button) {
          activateButton(button);
          document.getElementById(
            "activatedCell"
          ).textContent = `${currentPosition.x},${currentPosition.y} → ${magnifiedPosition.x},${magnifiedPosition.y}`;

          // Close magnifier
          magnifier.remove();

          // Reset grid cells and hide overlay
          resetGridCells();
          document.querySelector(".grid-overlay").style.display = "none";
          gridVisible = false;

          // Reset multiShakeCount to avoid confusion
          multiShakeCount = 0;
        }
      }

      /**
       * Handles shake actions based on shake count and current UI state
       * @param {number} shakeCount - Number of shakes detected
       */
      function handleShakeAction(shakeCount) {
        // Check if we're in magnified view
        const magnifier = document.querySelector(".magnifier-window");
        const isMagnifiedMode = magnifier !== null;

        // Handle based on shake count and current state
        if (shakeCount === 1) {
          if (isMagnifiedMode) {
            // For magnifier, set up a timer to wait for potential additional shakes
            if (magnifierShakeTimeoutId) {
              clearTimeout(magnifierShakeTimeoutId);
            }

            magnifierShakeTimeoutId = setTimeout(() => {
              // If we still only have a single shake after timeout
              if (multiShakeCount === 1) {
                const currentMagnifier =
                  document.querySelector(".magnifier-window");
                if (
                  currentMagnifier &&
                  currentMagnifier.getAttribute("data-shake-handled") ===
                    "false"
                ) {
                  handleMagnifierShake();
                }
              }
            }, 500);
          } else if (!gridVisible) {
            // If grid isn't visible, show it
            document.querySelector(".grid-overlay").style.display = "block";
            gridVisible = true;
            currentPosition = { x: 0, y: 0 };
            updateGridHighlight();
          } else {
            // Regular grid mode - activate based on current position
            document.getElementById(
              "activatedCell"
            ).textContent = `${currentPosition.x},${currentPosition.y}`;

            // Find and activate the corresponding button
            const buttonToActivate = calculateButtonFromCell(
              currentPosition.x,
              currentPosition.y
            );

            if (buttonToActivate) {
              activateButton(buttonToActivate);

              // Hide the grid after button activation
              document.querySelector(".grid-overlay").style.display = "none";
              gridVisible = false;
            }
          }
        } else if (shakeCount === 2) {
          if (gridVisible && !isMagnifiedMode) {
            // Remove selection highlight first
            document.querySelectorAll(".grid-cell").forEach((cell) => {
              cell.classList.remove("selected");
            });

            // Reset magnified position
            magnifiedPosition = { x: 0, y: 0 };

            // Prepare grid cell and show magnifier
            prepareGridCellForMagnification(
              currentPosition.x,
              currentPosition.y
            );
            captureAndMagnifyGrid(currentPosition.x, currentPosition.y);

            // Update UI
            document.getElementById(
              "currentCell"
            ).textContent = `${currentPosition.x},${currentPosition.y} → ${magnifiedPosition.x},${magnifiedPosition.y}`;
          }
        } else if (shakeCount === 3) {
          // Triple shake exits whatever current mode we're in
          if (isMagnifiedMode) {
            // Exit magnifier mode
            magnifier.remove();
            resetGridCells();
            document.querySelector(".grid-overlay").style.display = "block";
            gridVisible = true;
            updateGridHighlight();
          } else if (gridVisible) {
            // Exit grid mode
            resetGridCells();
            document.querySelector(".grid-overlay").style.display = "none";
            gridVisible = false;
          }
          multiShakeCount = 0;
        }
      }

      /**
       * Handles device motion for shake detection
       * @param {DeviceMotionEvent} event - Device motion event
       */
      function handleMotion(event) {
        const now = Date.now();
        const isMagnifiedMode =
          document.querySelector(".magnifier-window") !== null;

        // Use appropriate shake threshold based on mode
        const shakeThreshold = isMagnifiedMode
          ? SHAKE_THRESHOLD_MAGNIFIED
          : SHAKE_THRESHOLD_DEFAULT;

        // Avoid shake detection during tilt-flick to prevent accidental triggers
        if (gridVisible && now - lastTiltFlick < TILT_SHAKE_IGNORE_DELAY) {
          return;
        }

        // Extract and display acceleration values
        const x = roundNumber(event.acceleration.x);
        const y = roundNumber(event.acceleration.y);
        const z = roundNumber(event.acceleration.z);

        document.getElementById("accX").textContent = x;
        document.getElementById("accY").textContent = y;
        document.getElementById("accZ").textContent = z;

        // Detect shake using mode-specific threshold
        if (
          Math.abs(x) > shakeThreshold ||
          Math.abs(y) > shakeThreshold ||
          Math.abs(z) > shakeThreshold
        ) {
          if (now - lastShake > SHAKE_WINDOW) {
            // Check if within multi-shake window
            if (now - shakeStart < MULTI_SHAKE_WINDOW) {
              multiShakeCount++;
            } else {
              shakeStart = now;
              multiShakeCount = 1;
            }

            document.getElementById("shakeType").textContent =
              multiShakeCount + "x shake";

            // Handle magnifier mode separately
            const magnifier = document.querySelector(".magnifier-window");
            if (magnifier) {
              if (multiShakeCount === 1) {
                // Set up timer for potential follow-up shakes
                if (magnifierShakeTimeoutId) {
                  clearTimeout(magnifierShakeTimeoutId);
                }

                magnifierShakeTimeoutId = setTimeout(() => {
                  if (multiShakeCount === 1) {
                    const currentMagnifier =
                      document.querySelector(".magnifier-window");
                    if (
                      currentMagnifier &&
                      currentMagnifier.getAttribute("data-shake-handled") ===
                        "false"
                    ) {
                      handleMagnifierShake();
                    }
                  }
                }, 500);
              } else if (multiShakeCount === 3) {
                // Triple shake in magnifier mode exits immediately
                if (magnifierShakeTimeoutId) {
                  clearTimeout(magnifierShakeTimeoutId);
                  magnifierShakeTimeoutId = null;
                }

                magnifier.remove();
                resetGridCells();
                document.querySelector(".grid-overlay").style.display = "none";
                gridVisible = false;
                multiShakeCount = 0;
              }

              lastShake = now;
              return; // Skip the rest of shake detection for magnifier mode
            }

            // Handle regular mode shake actions with debouncing
            if (!isProcessingShake) {
              // Clear any existing timeout
              if (shakeTimeoutId) {
                clearTimeout(shakeTimeoutId);
              }

              // Set timeout to wait for potential additional shakes
              shakeTimeoutId = setTimeout(() => {
                if (!isProcessingShake) {
                  isProcessingShake = true;
                  handleShakeAction(multiShakeCount);
                  isProcessingShake = false;

                  // Reset count after handling
                  if (multiShakeCount !== 1) {
                    multiShakeCount = 0;
                  }
                }
              }, 500);
            }

            lastShake = now;
          }
        } else if (now - lastShake > SHAKE_RESET_DELAY) {
          // Reset shake count after delay with no shakes
          multiShakeCount = 0;
          document.getElementById("shakeType").textContent = "none";
        }
      }

      /**
       * Toggles sensor activation and resets the UI state
       */
      function toggleSensors() {
        const button = document.getElementById("sensorToggle");

        if (!sensorsActive) {
          // Enable sensors with permission request if needed
          if (typeof DeviceOrientationEvent.requestPermission === "function") {
            DeviceOrientationEvent.requestPermission().then((response) => {
              if (response == "granted") {
                window.addEventListener("deviceorientation", handleOrientation);
                window.addEventListener("devicemotion", handleMotion);
                sensorsActive = true;
                button.textContent = "Stop/Reset";
              }
            });
          } else {
            window.addEventListener("deviceorientation", handleOrientation);
            window.addEventListener("devicemotion", handleMotion);
            sensorsActive = true;
            button.textContent = "Stop/Reset";
          }
        } else {
          // Disable sensors and reset UI
          window.removeEventListener("deviceorientation", handleOrientation);
          window.removeEventListener("devicemotion", handleMotion);
          sensorsActive = false;
          button.textContent = "Start";

          // Reset all UI elements and states
          document.getElementById("currentBeta").textContent = "0";
          document.getElementById("currentGamma").textContent = "0";
          document.getElementById("accX").textContent = "0";
          document.getElementById("accY").textContent = "0";
          document.getElementById("accZ").textContent = "0";
          document.getElementById("tiltFlickDirection").textContent = "none";
          document.getElementById("shakeType").textContent = "none";
          document.getElementById("activatedButton").textContent = "none";
          document.getElementById("currentCell").textContent = "0,0";
          document.getElementById("activatedCell").textContent = "none";

          // Remove highlights from all buttons
          document.querySelectorAll(".grid-button").forEach((button) => {
            button.classList.remove("selected");
          });
          lastActivatedButton = null;

          // Hide grid and reset position
          gridVisible = false;
          document.querySelector(".grid-overlay").style.display = "none";
          currentPosition = { x: 0, y: 0 };
          magnifiedPosition = { x: 0, y: 0 };

          // Reset grid cells
          resetGridCells();

          // Remove magnifier window if present
          const magnifier = document.querySelector(".magnifier-window");
          if (magnifier) {
            magnifier.remove();
          }

          // Reset other state variables
          lastShake = 0;
          shakeTimeoutId = null;
          isProcessingShake = false;
          multiShakeCount = 0;
          shakeStart = 0;
          lastBeta = 0;
          lastGamma = 0;
          lastTiltFlick = 0;
          tiltFlickDirection = "none";
        }
      }

      // Initialize the grid when the page loads
      window.onload = function () {
        generateGrids();
      };
    </script>
  </head>
  <body>
    <h3>Mobile HCI (H): Tilt-Flick Grid-Based Input</h3>
    <p>
      <b>Dulapah Vibulsanti - 2920990v</b>
    </p>
    <p>
      Source code:
      <a href="https://glitch.com/edit/#!/mhci-2920990v"
        >https://glitch.com/edit/#!/mhci-2920990v</a
      >
    </p>
    <ol>
      <li>
        <b>Start:</b> Click the "Start" button and grant sensor permissions
      </li>
      <li>
        <b>Navigate:</b> Tilt-flick device left/right/outward/inward to move
        grid selection
      </li>
      <li>
        <b>Interact:</b>
        <ul>
          <li>
            Shake <b>once</b> to activate the button underneath your grid
            selection
          </li>
          <li>
            Shake <b>twice</b> to magnify the selected cell for precise
            selection
          </li>
          <li>Shake <b>three times</b> to exit current mode</li>
        </ul>
      </li>
      <li><b>Exit:</b> Click "Stop/Reset" when finished</li>
    </ol>
    <p>
      The stats section below shows your current position, activated buttons,
      and sensor readings.
    </p>
    <details class="tutorial-section">
      <summary>How To Use: Step-by-Step Guide with Animations</summary>

      <div class="tutorial-content">
        <div class="step-container">
          <h4>Step 1: Activate the Grid</h4>
          <div class="gesture-card">
            <div class="gesture-title">Display Selection Grid</div>
            <div class="gesture-description">
              Shake your device once to show the navigation grid
            </div>
            <div class="phone-animation-container shake-once">
              <div class="phone-outline">
                <div class="phone-screen"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="step-container">
          <h4>Step 2: Navigate the Grid</h4>
          <div class="gesture-grid">
            <div class="gesture-card">
              <div class="gesture-title">Move Left</div>
              <div class="gesture-description">
                Tilt-flick your device to the left
              </div>
              <div class="phone-animation-container tilt-left">
                <div class="phone-outline">
                  <div class="phone-screen"></div>
                </div>
                <div class="direction-arrow arrow-left">←</div>
              </div>
            </div>

            <div class="gesture-card">
              <div class="gesture-title">Move Right</div>
              <div class="gesture-description">
                Tilt-flick your device to the right
              </div>
              <div class="phone-animation-container tilt-right">
                <div class="phone-outline">
                  <div class="phone-screen"></div>
                </div>
                <div class="direction-arrow arrow-right">→</div>
              </div>
            </div>

            <div class="gesture-card">
              <div class="gesture-title">Move Up</div>
              <div class="gesture-description">
                Tilt-flick the top of your device outward/forward
              </div>
              <div class="phone-animation-container tilt-forward">
                <div class="phone-outline">
                  <div class="phone-screen"></div>
                </div>
                <div class="direction-arrow arrow-up">↑</div>
              </div>
            </div>

            <div class="gesture-card">
              <div class="gesture-title">Move Down</div>
              <div class="gesture-description">
                Tilt-flick the top of your device inward/backward
              </div>
              <div class="phone-animation-container tilt-backward">
                <div class="phone-outline">
                  <div class="phone-screen"></div>
                </div>
                <div class="direction-arrow arrow-down">↓</div>
              </div>
            </div>
          </div>
        </div>

        <div class="step-container">
          <h4>Step 3: Select a Button</h4>
          <div class="gesture-card">
            <div class="gesture-title">Activate Selected Button</div>
            <div class="gesture-description">
              Once positioned over desired button, shake once to select it
            </div>
            <div class="phone-animation-container shake-once">
              <div class="phone-outline">
                <div class="phone-screen"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="step-container">
          <h4>Step 4: Precision Selection (Optional)</h4>
          <div class="gesture-card">
            <div class="gesture-title">Activate Magnified View</div>
            <div class="gesture-description">
              Shake twice to open the precision subgrid for more accurate
              selection
            </div>
            <div class="phone-animation-container shake-twice">
              <div class="phone-outline">
                <div class="phone-screen"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="step-container">
          <h4>Step 5: Exit Current Mode (Optional)</h4>
          <div class="gesture-card">
            <div class="gesture-title">Return to Normal View</div>
            <div class="gesture-description">
              Shake three times to exit grid or magnified view
            </div>
            <div class="phone-animation-container shake-thrice">
              <div class="phone-outline">
                <div class="phone-screen"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </details>
    <button onclick="toggleSensors()" id="sensorToggle" class="control-button">
      Start
    </button>

    <div class="device-container">
      <div class="button-container"></div>
      <div class="grid-overlay">
        <div class="grid-container"></div>
      </div>
    </div>

    <div class="stats-container">
      <h2>Grid Navigation</h2>
      <p>Base Grid Position: <span id="currentCell" class="value">0,0</span></p>
      <p>
        Last Activated Position:
        <span id="activatedCell" class="value">none</span>
      </p>
      <p>
        Last Activated Button:
        <span id="activatedButton" class="value">none</span>
      </p>
    </div>

    <div class="stats-container">
      <h2>Current Tilt</h2>
      <p>Forward/Back (β): <span id="currentBeta" class="value">0</span>°</p>
      <p>Left/Right (γ): <span id="currentGamma" class="value">0</span>°</p>
    </div>

    <div class="stats-container">
      <h2>Tilt-Flick Detection</h2>
      <p>
        Last Direction: <span id="tiltFlickDirection" class="value">none</span>
      </p>
    </div>

    <div class="stats-container">
      <h2>Acceleration</h2>
      <p>X: <span id="accX" class="value">0</span></p>
      <p>Y: <span id="accY" class="value">0</span></p>
      <p>Z: <span id="accZ" class="value">0</span></p>
    </div>

    <div class="stats-container">
      <h2>Shake Detection</h2>
      <p>Sequence: <span id="shakeType" class="value">none</span></p>
    </div>
  </body>
</html>
